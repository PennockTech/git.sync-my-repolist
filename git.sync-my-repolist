#!/usr/bin/env python3

"""
git.sync-my-repolist: sync all my repos, per config file

A gross crude hack but convenient.
"""

__author__ = 'phil.pennock@spodhuis.org (Phil Pennock)'

import argparse
import glob
import os.path
import subprocess
import sys

_DEF_CONFIGFILENAME = '~/etc/git-repolist.conf'

OPTIONS=None
REPO_LIST = []
PREFER_REMOTES = []

class Error(Exception):
  """Base class for exceptions from git.sync-my-repolist."""
  pass


def extract_existing_repos(fh):
  keyword_handlers = {
      'dir': lambda d, c: _extract_one_candidate(os.path.expanduser(d), c),
      'repo': lambda d, c: _extract_one_candidate(os.path.expanduser(d), c),
      'glob': lambda p, c: [_extract_one_candidate(d, c) for d in glob.iglob(os.path.expanduser(p), recursive=True)],
      'prefer_remotes': lambda r, c: PREFER_REMOTES.extend(r.split())
      }
  errored = False
  for lnum, l in enumerate(fh):
    l = l.strip()
    if not l or l.startswith('#'):
      continue
    if ' ' in l:
      keyword, param = l.split(None, 1)
    else:
      keyword = 'dir'
      param = l

    ctx = { 'linenum': lnum+1, 'line': l }
    ctx['keyword'] = keyword
    ctx['param'] = param

    keyword = keyword.lower()
    if keyword in keyword_handlers:
      keyword_handlers[keyword](param, ctx)
    else:
      print('config line {linenum} unknown keyword: {keyword!r}'.format(**ctx), file=sys.stderr)
      errored = True
  if errored:
    raise SystemExit()

def _extract_one_candidate(candidate, ctx):
  ctx = dict(ctx)
  ctx['repo'] = candidate
  if os.path.exists(candidate):
    REPO_LIST.append(ctx)
  elif OPTIONS.verbose:
    print('Skipping non-existent repo: {repo}'.format(**ctx))

def sync_all():
  for ctx in REPO_LIST:
    repo = ctx['repo']
    cmd = [OPTIONS.git, '-C', repo]

    remotes = []
    remotesCmd = subprocess.Popen(cmd + ['config', '--local', '--name-only', '--get-regexp', 'remote\.[^.]+\.url'],
        stdout=subprocess.PIPE)
    for l in remotesCmd.stdout:
      l = l.rstrip().decode('utf-8')
      if l.startswith('remote.') and l.endswith('.url'):
        remotes.append(l[7:-4])
    remotesCmd.wait()
    # ignore return code, will be 1 when no remotes, we have that anyway, and if caused by something else, stderr will pass-thru
    if not remotes:
      if OPTIONS.verbose:
        print('{repo!r}: no remotes found, skipping [from config line {linenum}]'.format(**ctx))
      continue
    remotes = set(remotes)

    if OPTIONS.verbose:
      print('In: {repo!r}'.format(**ctx))
      subprocess.check_call(cmd + ['status'])

    if not OPTIONS.not_really:
      for preferred in PREFER_REMOTES:
        if preferred in remotes:
          subprocess.check_call(cmd + ['fetch', preferred])
          remotes.discard(preferred)
      # We don't fetch _all_ remotes; if the branch/master is not in the already-fetched, it will be grabbed by the pull
      #subprocess.check_call(cmd + ['fetch', '--multiple'] + list(remotes))
      subprocess.check_call(cmd + ['pull'])

    elif OPTIONS.verbose:
      print('{repo!r}: skipping pull because --not-really'.format(**ctx))

def _main(args, argv0):
  parser = argparse.ArgumentParser(
      description=__doc__,
      formatter_class=argparse.RawDescriptionHelpFormatter)
      #allow_abbrev=False)
  parser.add_argument('-c', '--config',
                      type=argparse.FileType('r', encoding='UTF-8'),
                      default=os.path.expanduser(_DEF_CONFIGFILENAME),
                      help='Config file to read [%(default)s]')
  parser.add_argument('--git',
                      default='git',
                      help='Git executable to invoke [%(default)s]')
  parser.add_argument('-n', '--not-really',
                      action='store_true', default=False,
                      help='Make no mutating changes')
  parser.add_argument('-v', '--verbose',
                      action='count', default=0,
                      help='Be more verbose')
  global OPTIONS
  OPTIONS = parser.parse_args(args=args)

  extract_existing_repos(OPTIONS.config)

  sync_all()

if __name__ == '__main__':
  argv0 = sys.argv[0].rsplit('/')[-1]
  rv = _main(sys.argv[1:], argv0=argv0)
  sys.exit(rv)

# vim: set ft=python sw=2 expandtab :
