#!/usr/bin/env python3

"""
git.sync-my-repolist: sync all my repos, per config file

A gross crude hack but convenient.
"""

__author__ = 'phil.pennock@spodhuis.org (Phil Pennock)'

import argparse
import collections
import glob
import os.path
import subprocess
import sys

_DEF_CONFIGFILENAME = '~/etc/git-repolist.conf'
_DEF_GROUP = '_default_'

EXAMPLE_CONFIG = """#
# This is {default_configfn}
#
# No directives are required, although functionality will be limited
# with no repositories specified.  In the simplest case, a repo or two,
# one per line, specified without adornment, will do.
# Repository paths have ~ user-path expansion performed upon them.

# Any remotes specified here will be fetched before the pull, in the
# order given here, if they exist as names of remotes in that repo.
prefer_remotes github origin

# Override the default git command on this host:
git /opt/git-devel/bin/git

# Some repos to check out (all equivalent)
~/src/repo1
dir ~/src/repo2
repo ~/src/repo3

# Some other repos to pull
glob ~/go/src/github.com/myname/*

# We only pull project foo if explicitly requested
group foo
glob ~/go/foo.example.com/*
""".format(default_configfn=_DEF_CONFIGFILENAME)

class Error(Exception):
  """Base class for exceptions from git.sync-my-repolist."""
  pass

class ExitError(Error):
  """Error exception which should force exit without stack-trace."""
  pass

class Config(object):
  def __init__(self):
    self.OPTIONS = None
    self._git = None
    self.git_can_nameonly = False
    self.progname = '???'

  def parse_OPTIONS(self, options):
    self.OPTIONS = options
    self._git = options.git
    self.sub_command = None
    if options.subcommand_override:
      if options.subcommand_override[0] != '--':
        raise ExitError('git overrides should be after a --')
      self.sub_command = options.subcommand_override[1:]
      if not self.sub_command:
        self.sub_command = None

  def git(self):
    return str(self._git)

class Context(dict):
  def dup(self):
    return Context(self.copy())
  def verbose(self, template, **kwargs):
    return verbose(template, self, **kwargs)
  def __getattr__(self, key):
    return self[key]
  def __setattr__(self, key, nv):
    # we don't have any direct attrs which we want to allow to be overriden
    self[key] = nv
  def __dir__(self):
    return self.keys()
  def set(self, k, v):
    self[k] = v


# CONFIG: all metadata _except_ stuff directly set by the config file?
CONFIG = Config()

REPO_LISTS = collections.defaultdict(list)
PREFER_REMOTES = []

# We only support recursive globs if Python does in glob; not much point
# going further
if sys.version_info >= (3,5):
  def my_glob(pattern):
    return glob.iglob(os.path.expanduser(pattern), recursive=True)
else:
  def my_glob(pattern):
    return glob.iglob(os.path.expanduser(pattern))


class DefaultStr(object):
  """For when we want to have cmdline override config file."""
  def __init__(self, default):
    self.value = default
  def __str__(self):
    return self.value
  def __repr__(self):
    return repr(self.value)


def verbose(template, ctx, *, level=1, error=False):
  if CONFIG.OPTIONS.verbose < level:
    return
  out = sys.stderr if error else sys.stdout
  print(CONFIG.progname, ': ', template.format(**ctx), sep='', file=out)

def tune_for_environment():
  version = subprocess.check_output([CONFIG.git(), 'version'])
  if version.startswith(b'git version '):
    version = version[12:].rstrip().decode('ascii')
  else:
    raise Error('Unable to parse git version')
  version_info = tuple(map(int, version.split('.')))
  if version_info >= (2, 6):
    CONFIG.git_can_nameonly = True
  else:
    verbose('git too old ({v}) to support "config --name-only"', {'v': version})

def set_config(newvalue, ctx):
  ctx = ctx.dup()
  ctx.newvalue = newvalue
  keyattr = '_' + ctx.keyword

  v = getattr(CONFIG, keyattr)
  if v is None:
    ctx.verbose('not a tuneable config option {key!r}', level=0, error=True)
    return
  ctx.oldvalue = v
  if type(v) == DefaultStr:
    setattr(CONFIG, keyattr, newvalue)
    ctx.verbose('switched {keyword} from {oldvalue!r} to {newvalue!r}')
  else:
    ctx.verbose('ignored new {keyword} value from config line {linenum} because already explicitly set')
    ctx.verbose('{keyword} remains {oldvalue!r}, ignoring {newvalue!r}')

def parse_config(fh):
  group = [_DEF_GROUP]
  keyword_handlers = {
      'dir': lambda d, c: _extract_one_candidate(os.path.expanduser(d), c),
      'repo': lambda d, c: _extract_one_candidate(os.path.expanduser(d), c),
      'glob': lambda p, c: [_extract_one_candidate(d, c) for d in my_glob(p)],
      'prefer_remotes': lambda r, c: PREFER_REMOTES.extend(r.split()),
      'git': lambda p, c: set_config(p, c),
      'group': lambda g, c: group.insert(0, g),
      }
  errored = False
  for lnum, l in enumerate(fh):
    l = l.strip()
    if not l or l.startswith('#'):
      continue
    if ' ' in l:
      keyword, param = l.split(None, 1)
    else:
      keyword = 'dir'
      param = l

    ctx = Context(linenum=lnum+1, line=l, keyword=keyword, param=param, group=group[0])

    keyword = keyword.lower()
    if keyword in keyword_handlers:
      keyword_handlers[keyword](param, ctx)
    else:
      ctx.verbose('config line {linenum} unknown keyword: {keyword!r}', error=True, level=0)
      errored = True
  if errored:
    raise SystemExit()

def _extract_one_candidate(candidate, ctx):
  ctx = ctx.dup()
  ctx.repo = candidate
  if os.path.exists(candidate):
    if os.path.isdir(candidate):
      REPO_LISTS[ctx.group].append(ctx)
    else:
      # bump level because expect this to be files in a directory mostly holding repo subdirs
      ctx.verbose('Skipping non-directory: {repo!r}', level=2)
  else:
    ctx.verbose('Skipping non-existent repo: {repo!r}')

def sync_all(groupname):
  if not groupname:
    groupname = _DEF_GROUP
  for ctx in REPO_LISTS[groupname]:
    repo = ctx.repo
    cmd = [CONFIG.git(), '-C', repo]

    if CONFIG.OPTIONS.list_repos:
      ctx.verbose('{repo!r}', level=0)
      continue

    remotes = []
    cmdRemotes = cmd + 'config --local'.split()
    if CONFIG.git_can_nameonly:
      cmdRemotes += ['--name-only']
    cmdRemotes += ['--get-regexp', 'remote\.[^.]+\.url']
    # old versions of git lack the --name-only, but it makes things safer to use it if available
    # (the value can contain newlines)
    remotesCmd = subprocess.Popen(cmdRemotes, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    for l in remotesCmd.stdout:
      l = l.rstrip().decode('utf-8')
      if not CONFIG.git_can_nameonly:
        l = l.split(None, 1)[0]
      if l.startswith('remote.') and l.endswith('.url'):
        remotes.append(l[7:-4])
    remotesCmd.wait()
    # ignore return code, will be 1 when no remotes, we have that anyway, and if caused by something else, stderr will pass-thru
    if not remotes:
      ctx.verbose('{repo!r}: no remotes found, skipping [from config line {linenum}]')
      continue
    remotes = set(remotes)

    if CONFIG.OPTIONS.verbose:
      ctx.verbose('In: {repo!r}')
      subprocess.check_call(cmd + ['status'])

    if CONFIG.sub_command is not None:
      ctx.command_line = CONFIG.sub_command
      if CONFIG.OPTIONS.not_really:
        ctx.verbose('{repo!r}: skipping {command_line!r} because --not-really')
        continue
      subprocess.check_call(cmd + CONFIG.sub_command)
      continue

    if CONFIG.OPTIONS.not_really:
      ctx.verbose('{repo!r}: skipping pull because --not-really')
      continue

    for preferred in PREFER_REMOTES:
      if preferred in remotes:
        subprocess.check_call(cmd + ['fetch', preferred])
        remotes.discard(preferred)
    # We don't fetch _all_ remotes; if the branch/master is not in the already-fetched, it will be grabbed by the pull
    #subprocess.check_call(cmd + ['fetch', '--multiple'] + list(remotes))
    subprocess.check_call(cmd + ['pull'])

def _main(args, argv0):
  CONFIG.progname = argv0
  parser = argparse.ArgumentParser(
      description=__doc__,
      formatter_class=argparse.RawDescriptionHelpFormatter)
      #allow_abbrev=False)
  parser.add_argument('-c', '--config',
                      type=argparse.FileType('r', encoding='UTF-8'),
                      default=os.path.expanduser(_DEF_CONFIGFILENAME),
                      help='Config file to read [%(default)s]')
  parser.add_argument('--emit-example-config',
                      action='store_true', default=False,
                      help='Emit an example config to stdout and exit')
  parser.add_argument('--git',
                      default=DefaultStr('git'),
                      help='Git executable to invoke [%(default)s]')
  parser.add_argument('-g', '--group',
                      default='',
                      help='Sync a non-default group')
  parser.add_argument('--list-groups',
                      action='store_true', default=False,
                      help='List configured groups instead')
  parser.add_argument('--list-repos',
                      action='store_true', default=False,
                      help='List known repos we would act on instead')
  parser.add_argument('-n', '--not-really',
                      action='store_true', default=False,
                      help='Make no mutating changes')
  parser.add_argument('-v', '--verbose',
                      action='count', default=0,
                      help='Be more verbose')
  parser.add_argument('subcommand_override', nargs=argparse.REMAINDER)
  CONFIG.parse_OPTIONS(parser.parse_args(args=args))

  if CONFIG.OPTIONS.emit_example_config:
    print(EXAMPLE_CONFIG, end='')
    return 0

  tune_for_environment()

  parse_config(CONFIG.OPTIONS.config)

  if CONFIG.OPTIONS.list_groups:
    for g in sorted(REPO_LISTS.keys()):
      if g == _DEF_GROUP:
        continue
      print(g)
    return 0

  sync_all(CONFIG.OPTIONS.group)

if __name__ == '__main__':
  argv0 = sys.argv[0].rsplit('/')[-1]
  try:
    rv = _main(sys.argv[1:], argv0=argv0)
    sys.exit(rv)
  except ExitError as e:
    print('{0}: {1}'.format(argv0, e), file=sys.stderr)
    sys.exit(1)

# vim: set ft=python sw=2 expandtab :
